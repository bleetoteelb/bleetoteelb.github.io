---
layout: post
title:  "Algorithm에서 pseudocode 규칙"
subtitle:   "Algorithm에서 pseudocode 규칙"
categories: devlog
tags: algorithm
---

# pseudocode 규칙

아래 내용은 _Introduction to algorithms_ 에 나온 pseudocode 규칙을 옮겨 적은 것이다.

내용을 설명하는데에 필요한 pseudocode는 다음과 같다.
```
Procedure INSERTION-SORT(A)
1  for j ← 2 to length[A]
2      do key ← A[j]
3         ▷ A[j]를 정렬된 수열 A[1..j-1] 속에 삽입하기
4         i ← j-1
5         while i>0 and A[i] > key
6            do A[i+1] ← A[i]
7               i ← i-1
8         A[i+1] ← key
```


### 1. 
들여쓰기는 블록 구조를 나타낸다. 예를 들어, 1행에서 시작한 for 루프의 바디 부분은 2-8행으로 구성되고, 5행에서 시작한 while 루프는 6-7행은 포함하지만 8행은 포함하지 않는다. 이러한 들여쓰기 스타일은 if-then-else문에도 똑같이 적용된다. begin, end와 같은 전통적인 방법으로 블록 구조를 표현하는 것에 비해 들여쓰기를 할 경우 코드의 지저분함은 줄이면서도 명확함을 유지하거나 오히려 향상시킬 수 있다.  


-

-


### 2. 
while, for, repeat 같은 반복문과 if, then, else 같은 조건문은 파스칼에서와 비슷하게 해석된다. 그러나 for문의 경우에는 다소 차이점이 있다. 파스칼에서는 루프를 빠져 나올 때 루프 카운트 변수의 값은 정의되지 않은 값으로 바뀌지만 이 책에서는 그 값을 유지하는 것으로 해석한다. 즉, for 루프를 빠져 나온 순간, 루프 카운트의 값은 for의 타당성을 증명하는 과정에서 이미 이용했다. 1행에서 for 루프 헤더는 for j←2 to _length_ [A]이며, 루프가 종료될 때의 값은 j= _length_ [A]+1이다.(또는 n= _length_ [A]일 때 j=n+1이다)  

-
### 3. 
기호 "▷"는 주석을 나타낸다.  

-

-

### 4. 
i ← j ← e 형태의 다중 할당식은 두 변수 i,j에 식 e의 값을 할당하는 것을 말한다. 이는 j ← e할당식이 실행된 뒤, i ← j 할당식이 실행되는 것과 같다.  

-

-

### 5. 
i, j, key와 같은 변수들은 그것들이 속하는 함수에서 지역 변수가 된다. 이 책에서 전역 변수를 사용할 경우에는 반드시 그 사실을 명시하고 있다.

-

-
### 6. 
배열의 원소는 배열 이름 다음에 사각 괄호 안에 인덱스를 사용함으로써 그 내용에 접근한다. 예를 들어, A[i]는 배열 A의 i번째 값을 나타낸다. 그리고 ".."은 배열에서 연속적인 원소들을 가리킨다. 그러므로 A[1..j]은 j개의 원소 A[1],A[2],...,A[j]로 구성된 a의 부분 배열을 뜻한다.

-

-

### 7. 
복합 데이터는 전형적으로 객체의 형태로 만들어지며 객체는 특성들, 즉 필드들로 구성된다. 특정 필드의 값은 필드 이름 다음의 사각 괄호 안에 객체 이름을 넣음으로써 구할 수 있다. 예를 들어, 배열은 일종의 객체이고 그것에는 몇개의 원소들이 포함되는지를 나타내는 특성 _length_ 가 정의된다. 그래서 어떤 배열 A의 원소의 개수를 구하기 위해서는 _length_ [A]라고 쓰면 된다. 이처럼 배열의 인덱스나 객체 특성을 위해서 모두 사각 괄호를 쓰게 되어 혼란스럽게 느껴질지 모르겠지만 대개는 문맥상 무엇을 의미하는지 분명히 알 수 있다.

배열과 같은 객체를 나타내는 변수는 그 내용을 담고 있는 데이터에 대한 포인터처럼 다루어진다. y ← x라는 명령문이 실행되면 객체 x의 모든 필드 f는 f[y] = f[x]를 만족한다. 이에 더하여 이제 f[x] ← 3을 실행하면 f[x]=3은 물론이거니와 f[y] = 3이 되는것이다. 바꾸어 말하면 x와 y는 y ← x 할당문이 실행되고 나면 같은 객체를 가리키는 포인터인 것이다.

가끔 포인터는 어떤 객체도 가리키지 않을 수 있다. 이 경우, 그 포인터에는 NIL이라는 특수한 값을 준다.  


-


-
### 8. 
함수의 인자들은 값에 의해 전달된다(call by value). 피호출 함수는 인자들에 대해 자신만의 복사본을 가지며 거기에서 인자에 어떤 값이 할당되더라도 호출 함수에서는 값의 변화를 알 수 없다. 객체가 전달될 경우, 객체의 데이터를 가리키는 포인터는 복사되지만, 그 객체의 필드들은 복사되지 않는다. 예를 들어, x가 피호출 함수의 인자일 때 x ← y 할당문이 피호출 함수 내에서 실행되면 호출 함수에는 그 변화가 보이지 않는다. 그러나 f[x] ← 3과 같은 할당문은 호출 함수에서도 그 변화를 알 수 있다.

-

-

### 9. 
"and"와 "or" 같은 이진 논리 연산자들은 조기찯단 할 수 있다. 즉, "x and y"문을 꼐산할 때 먼저 x를 계산한다. 만약, x가 FALSE라면 그 식의 결과는 TRUE가 될 수 없으며 따라서 y를 아예 계산하지 않는다. 반면에 x가 TRUE라면 그 식의 결과를 계산하기 위해서 y값도 반드시 계산해야 한다. 비슷하게 "x or y" 식에서 x의 결과값이 FALSE 일 경우에만 y를 계산한다. 이렇게 조기차단되는 연산자들을 사용하면 "x =/= NIL and f[x]=y"와 같은 이진 논리 식에서 x가 NIL일 떄 f[x]의 계산을 시도하는 오류 상황을 염려하지 않고 사용할 수 있게 된다.